import { z } from "zod";
import { _OperationResponse } from "../core";
import { createExecutableTools } from "../core/request";
import { blNodeType } from "../../../scripts/generators/python/geo-node-types.generated";

// Define base port types
const PORT_TYPE = z
  .enum([
    "int",
    "float",
    "vec2",
    "vec3",
    "vec4",
    "bool",
    "string",
    "geometry",
    "material",
  ])
  .describe("Base data types for geometry nodes");

// Define port structure
const PORT = z.object({
  name: z.string().describe("Port name"),
  type: PORT_TYPE.describe("Port data type"),
  description: z
    .string()
    .optional()
    .describe("Description of what this port does"),
});

// Create a NodeDefinition type to document each node type
const NODE_DEFINITION = z.object({
  type: z.string().describe("Unique node type identifier"),
  description: z.string().describe("Description of what this node does"),
  inputs: z.array(PORT).describe("Available input ports"),
  outputs: z.array(PORT).describe("Available output ports"),
  properties: z.record(z.any()).optional().describe("Configurable properties"),
});

// Define node catalog
const NODE_CATALOG = {
  mesh_cube: {
    type: "mesh_cube",
    description: "Creates a cube mesh geometry",
    inputs: [],
    outputs: [
      {
        name: "geometry",
        type: "geometry",
        description: "The output cube geometry",
      },
    ],
    properties: {
      size: {
        type: "vec3",
        default: [1, 1, 1],
        description: "Width, height, depth of the cube",
      },
      verticesX: {
        type: "int",
        default: 2,
        description: "Number of vertices along X axis",
      },
      verticesY: {
        type: "int",
        default: 2,
        description: "Number of vertices along Y axis",
      },
      verticesZ: {
        type: "int",
        default: 2,
        description: "Number of vertices along Z axis",
      },
    },
  },
  mesh_cylinder: {
    type: "mesh_cylinder",
    description: "Creates a cylinder mesh geometry",
    inputs: [],
    outputs: [
      {
        name: "geometry",
        type: "geometry",
        description: "The output cylinder geometry",
      },
    ],
    properties: {
      vertices: {
        type: "int",
        default: 32,
        description: "Number of vertices around the circumference",
      },
      radius: {
        type: "float",
        default: 1,
        description: "Radius of the cylinder",
      },
      depth: {
        type: "float",
        default: 2,
        description: "Depth of the cylinder",
      },
    },
  },
  mesh_sphere: {
    type: "mesh_sphere",
    description: "Creates a sphere mesh geometry",
    inputs: [],
    outputs: [
      {
        name: "geometry",
        type: "geometry",
        description: "The output sphere geometry",
      },
    ],
    properties: {
      radius: {
        type: "float",
        default: 1,
        description: "Radius of the sphere",
      },
      rings: {
        type: "int",
        default: 16,
        description: "Number of horizontal divisions",
      },
      segments: {
        type: "int",
        default: 32,
        description: "Number of vertical divisions",
      },
    },
  },
  output: {
    type: "output",
    description: "Final output node for the geometry",
    inputs: [
      {
        name: "geometry",
        type: "geometry",
        description: "Input geometry to output",
      },
    ],
    outputs: [],
    properties: {},
  },
};

// const getNodeDefinition = (nodeType: keyof typeof NODE_CATALOG) => {
//   return NODE_CATALOG[nodeType] || null;
// };

const NODES = z.discriminatedUnion("type", [
  z.object({
    type: z.literal("mesh_cube"),
    properties: z.object({
      size: z.array(z.number()).length(3).optional(),
      verticesX: z.number().optional(),
      verticesY: z.number().optional(),
      verticesZ: z.number().optional(),
    }),
  }),

  z.object({
    type: z.literal("mesh_cylinder"),
    properties: z.object({
      vertices: z.number().int().optional(),
      radius: z.number().optional(),
      depth: z.number().optional(),
    }),
  }),

  z.object({
    type: z.literal("mesh_sphere"),
    properties: z.object({
      radius: z.number().optional(),
      rings: z.number().int().optional(),
      segments: z.number().int().optional(),
    }),
  }),
  z.object({
    type: z.literal("output"),
    properties: z.object({
      geometry: z.string().optional(),
    }),
  }),
]);

const autoGeneratedAtomicTools = {
  addShaderNodeValue: {
    description: "Adds a ShaderNodeValue node to the graph.",
    parameters: z.object({
      "Value test": z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeValToRGB: {
    description: "Adds a ShaderNodeValToRGB node to the graph.",
    parameters: z.object({
      Fac: z.number().optional().default(0.5).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeVectorCurve: {
    description: "Adds a ShaderNodeVectorCurve node to the graph.",
    parameters: z.object({
      Fac: z.number().optional().describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeRGBCurve: {
    description: "Adds a ShaderNodeRGBCurve node to the graph.",
    parameters: z.object({
      Fac: z.number().optional().describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeMapRange: {
    description: "Adds a ShaderNodeMapRange node to the graph.",
    parameters: z.object({
      Value: z.number().optional().describe(". Type : Float"),
      "From Min": z.number().optional().describe(". Type : Float"),
      "From Max": z.number().optional().describe(". Type : Float"),
      "To Min": z.number().optional().describe(". Type : Float"),
      "To Max": z.number().optional().describe(". Type : Float"),
      Steps: z.number().optional().describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      From_Min_FLOAT3: z
        .array(z.number())
        .optional()
        .describe(". Type : Vector"),
      From_Max_FLOAT3: z
        .array(z.number())
        .optional()
        .default([1, 1, 1])
        .describe(". Type : Vector"),
      To_Min_FLOAT3: z.array(z.number()).optional().describe(". Type : Vector"),
      To_Max_FLOAT3: z
        .array(z.number())
        .optional()
        .default([1, 1, 1])
        .describe(". Type : Vector"),
      Steps_FLOAT3: z
        .array(z.number())
        .optional()
        .default([4, 4, 4])
        .describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeClamp: {
    description: "Adds a ShaderNodeClamp node to the graph.",
    parameters: z.object({
      Value: z.number().optional().default(1).describe(". Type : Float"),
      Min: z.number().optional().default(0).describe(". Type : Float"),
      Max: z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeMath: {
    description: "Adds a ShaderNodeMath node to the graph.",
    parameters: z.object({
      Value: z.number().optional().default(0.5).describe(". Type : Float"),
      Value_001: z.number().optional().default(0.5).describe(". Type : Float"),
      Value_002: z.number().optional().default(0.5).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeVectorMath: {
    description: "Adds a ShaderNodeVectorMath node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      Vector_001: z.array(z.number()).optional().describe(". Type : Vector"),
      Vector_002: z.array(z.number()).optional().describe(". Type : Vector"),
      Scale: z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeBlackbody: {
    description: "Adds a ShaderNodeBlackbody node to the graph.",
    parameters: z.object({
      Temperature: z
        .number()
        .optional()
        .default(1500)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexGradient: {
    description: "Adds a ShaderNodeTexGradient node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexNoise: {
    description: "Adds a ShaderNodeTexNoise node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      W: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexMagic: {
    description: "Adds a ShaderNodeTexMagic node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      Scale: z.number().optional().describe(". Type : Float"),
      Distortion: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexWave: {
    description: "Adds a ShaderNodeTexWave node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      Scale: z.number().optional().describe(". Type : Float"),
      Distortion: z.number().optional().describe(". Type : Float"),
      Detail: z.number().optional().describe(". Type : Float"),
      "Detail Scale": z.number().optional().describe(". Type : Float"),
      "Detail Roughness": z.number().optional().describe(". Type : Float"),
      "Phase Offset": z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexVoronoi: {
    description: "Adds a ShaderNodeTexVoronoi node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      W: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexChecker: {
    description: "Adds a ShaderNodeTexChecker node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexBrick: {
    description: "Adds a ShaderNodeTexBrick node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeVectorRotate: {
    description: "Adds a ShaderNodeVectorRotate node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      Center: z
        .array(z.number())
        .optional()
        .describe("Point to rotate around. Type : Vector"),
      Axis: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeSeparateXYZ: {
    description: "Adds a ShaderNodeSeparateXYZ node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeCombineXYZ: {
    description: "Adds a ShaderNodeCombineXYZ node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeTexWhiteNoise: {
    description: "Adds a ShaderNodeTexWhiteNoise node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      W: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeFloatCurve: {
    description: "Adds a ShaderNodeFloatCurve node to the graph.",
    parameters: z.object({
      Fac: z.number().optional().describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addShaderNodeMix: {
    description: "Adds a ShaderNodeMix node to the graph.",
    parameters: z.object({
      Factor_Float: z
        .number()
        .optional()
        .default(0.5)
        .describe(". Type : Float"),
      Factor_Vector: z
        .array(z.number())
        .optional()
        .default([0.5, 0.5, 0.5])
        .describe(". Type : Vector"),
      A_Float: z.number().optional().describe(". Type : Float"),
      B_Float: z.number().optional().describe(". Type : Float"),
      A_Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      B_Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeAlignEulerToVector: {
    description: "Adds a FunctionNodeAlignEulerToVector node to the graph.",
    parameters: z.object({
      Rotation: z.array(z.number()).optional().describe(". Type : Vector"),
      Factor: z.number().optional().default(1).describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeAlignRotationToVector: {
    description: "Adds a FunctionNodeAlignRotationToVector node to the graph.",
    parameters: z.object({
      Factor: z.number().optional().default(1).describe(". Type : Float"),
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeAxesToRotation: {
    description: "Adds a FunctionNodeAxesToRotation node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeAxisAngleToRotation: {
    description: "Adds a FunctionNodeAxisAngleToRotation node to the graph.",
    parameters: z.object({
      Axis: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeBooleanMath: {
    description: "Adds a FunctionNodeBooleanMath node to the graph.",
    parameters: z.object({
      Boolean: z.boolean().optional().describe(". Type : Bool"),
      Boolean_001: z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeCombineColor: {
    description: "Adds a FunctionNodeCombineColor node to the graph.",
    parameters: z.object({
      Red: z.number().optional().default(0).describe(". Type : Float"),
      Green: z.number().optional().default(0).describe(". Type : Float"),
      Blue: z.number().optional().default(0).describe(". Type : Float"),
      Alpha: z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeCombineMatrix: {
    description: "Adds a FunctionNodeCombineMatrix node to the graph.",
    parameters: z.object({
      "Column 1 Row 1": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Column 1 Row 2": z.number().optional().describe(". Type : Float"),
      "Column 1 Row 3": z.number().optional().describe(". Type : Float"),
      "Column 1 Row 4": z.number().optional().describe(". Type : Float"),
      "Column 2 Row 1": z.number().optional().describe(". Type : Float"),
      "Column 2 Row 2": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Column 2 Row 3": z.number().optional().describe(". Type : Float"),
      "Column 2 Row 4": z.number().optional().describe(". Type : Float"),
      "Column 3 Row 1": z.number().optional().describe(". Type : Float"),
      "Column 3 Row 2": z.number().optional().describe(". Type : Float"),
      "Column 3 Row 3": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Column 3 Row 4": z.number().optional().describe(". Type : Float"),
      "Column 4 Row 1": z.number().optional().describe(". Type : Float"),
      "Column 4 Row 2": z.number().optional().describe(". Type : Float"),
      "Column 4 Row 3": z.number().optional().describe(". Type : Float"),
      "Column 4 Row 4": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeQuaternionToRotation: {
    description: "Adds a FunctionNodeQuaternionToRotation node to the graph.",
    parameters: z.object({
      W: z.number().optional().default(1).describe(". Type : Float"),
      X: z.number().optional().default(0).describe(". Type : Float"),
      Y: z.number().optional().default(0).describe(". Type : Float"),
      Z: z.number().optional().default(0).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeCombineTransform: {
    description: "Adds a FunctionNodeCombineTransform node to the graph.",
    parameters: z.object({
      Translation: z.array(z.number()).optional().describe(". Type : Vector"),
      Scale: z
        .array(z.number())
        .optional()
        .default([1, 1, 1])
        .describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeCompare: {
    description: "Adds a FunctionNodeCompare node to the graph.",
    parameters: z.object({
      A: z.number().optional().describe(". Type : Float"),
      B: z.number().optional().describe(". Type : Float"),
      A_INT: z.number().int().optional().describe(". Type : Int"),
      B_INT: z.number().int().optional().describe(". Type : Int"),
      A_VEC3: z.array(z.number()).optional().describe(". Type : Vector"),
      B_VEC3: z.array(z.number()).optional().describe(". Type : Vector"),
      A_STR: z.string().optional().describe(". Type : String"),
      B_STR: z.string().optional().describe(". Type : String"),
      C: z.number().optional().default(0.9).describe(". Type : Float"),
      Angle: z
        .number()
        .optional()
        .default(0.0872665)
        .describe(". Type : Float"),
      Epsilon: z.number().optional().default(0.001).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeEulerToRotation: {
    description: "Adds a FunctionNodeEulerToRotation node to the graph.",
    parameters: z.object({
      Euler: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeFloatToInt: {
    description: "Adds a FunctionNodeFloatToInt node to the graph.",
    parameters: z.object({
      Float: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputBool: {
    description: "Adds a FunctionNodeInputBool node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputColor: {
    description: "Adds a FunctionNodeInputColor node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputInt: {
    description: "Adds a FunctionNodeInputInt node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputRotation: {
    description: "Adds a FunctionNodeInputRotation node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputSpecialCharacters: {
    description: "Adds a FunctionNodeInputSpecialCharacters node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputString: {
    description: "Adds a FunctionNodeInputString node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInputVector: {
    description: "Adds a FunctionNodeInputVector node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInvertMatrix: {
    description: "Adds a FunctionNodeInvertMatrix node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeInvertRotation: {
    description: "Adds a FunctionNodeInvertRotation node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeMatrixMultiply: {
    description: "Adds a FunctionNodeMatrixMultiply node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeProjectPoint: {
    description: "Adds a FunctionNodeProjectPoint node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRandomValue: {
    description: "Adds a FunctionNodeRandomValue node to the graph.",
    parameters: z.object({
      Min: z.array(z.number()).optional().describe(". Type : Vector"),
      Max: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeReplaceString: {
    description: "Adds a FunctionNodeReplaceString node to the graph.",
    parameters: z.object({
      String: z.string().optional().describe(". Type : String"),
      Find: z
        .string()
        .optional()
        .describe("The string to find in the input string. Type : String"),
      Replace: z
        .string()
        .optional()
        .describe("The string to replace each match with. Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotateEuler: {
    description: "Adds a FunctionNodeRotateEuler node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotateRotation: {
    description: "Adds a FunctionNodeRotateRotation node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotateVector: {
    description: "Adds a FunctionNodeRotateVector node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotationToAxisAngle: {
    description: "Adds a FunctionNodeRotationToAxisAngle node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotationToEuler: {
    description: "Adds a FunctionNodeRotationToEuler node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeSeparateColor: {
    description: "Adds a FunctionNodeSeparateColor node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeSeparateMatrix: {
    description: "Adds a FunctionNodeSeparateMatrix node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeRotationToQuaternion: {
    description: "Adds a FunctionNodeRotationToQuaternion node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeSeparateTransform: {
    description: "Adds a FunctionNodeSeparateTransform node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeSliceString: {
    description: "Adds a FunctionNodeSliceString node to the graph.",
    parameters: z.object({
      String: z.string().optional().describe(". Type : String"),
      Position: z.number().int().optional().describe(". Type : Int"),
      Length: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeStringLength: {
    description: "Adds a FunctionNodeStringLength node to the graph.",
    parameters: z.object({
      String: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeTransformDirection: {
    description: "Adds a FunctionNodeTransformDirection node to the graph.",
    parameters: z.object({
      Direction: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeTransformPoint: {
    description: "Adds a FunctionNodeTransformPoint node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeTransposeMatrix: {
    description: "Adds a FunctionNodeTransposeMatrix node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addFunctionNodeValueToString: {
    description: "Adds a FunctionNodeValueToString node to the graph.",
    parameters: z.object({
      Value: z.number().optional().describe(". Type : Float"),
      Decimals: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeAccumulateField: {
    description: "Adds a GeometryNodeAccumulateField node to the graph.",
    parameters: z.object({
      Value: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeAttributeDomainSize: {
    description: "Adds a GeometryNodeAttributeDomainSize node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeAttributeStatistic: {
    description: "Adds a GeometryNodeAttributeStatistic node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeBake: {
    description: "Adds a GeometryNodeBake node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeBlurAttribute: {
    description: "Adds a GeometryNodeBlurAttribute node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeBoundBox: {
    description: "Adds a GeometryNodeBoundBox node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCaptureAttribute: {
    description: "Adds a GeometryNodeCaptureAttribute node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCollectionInfo: {
    description: "Adds a GeometryNodeCollectionInfo node to the graph.",
    parameters: z.object({
      "Separate Children": z.boolean().optional().describe(". Type : Bool"),
      "Reset Children": z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeConvexHull: {
    description: "Adds a GeometryNodeConvexHull node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveEndpointSelection: {
    description: "Adds a GeometryNodeCurveEndpointSelection node to the graph.",
    parameters: z.object({
      "Start Size": z.number().int().optional().describe(". Type : Int"),
      "End Size": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveHandleTypeSelection: {
    description:
      "Adds a GeometryNodeCurveHandleTypeSelection node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveLength: {
    description: "Adds a GeometryNodeCurveLength node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveArc: {
    description: "Adds a GeometryNodeCurveArc node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurvePrimitiveBezierSegment: {
    description:
      "Adds a GeometryNodeCurvePrimitiveBezierSegment node to the graph.",
    parameters: z.object({
      Resolution: z
        .number()
        .int()
        .optional()
        .default(16)
        .describe(". Type : Int"),
      Start: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurvePrimitiveCircle: {
    description: "Adds a GeometryNodeCurvePrimitiveCircle node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurvePrimitiveLine: {
    description: "Adds a GeometryNodeCurvePrimitiveLine node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveQuadraticBezier: {
    description: "Adds a GeometryNodeCurveQuadraticBezier node to the graph.",
    parameters: z.object({
      Resolution: z
        .number()
        .int()
        .optional()
        .default(16)
        .describe(". Type : Int"),
      Start: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurvePrimitiveQuadrilateral: {
    description:
      "Adds a GeometryNodeCurvePrimitiveQuadrilateral node to the graph.",
    parameters: z.object({
      Width: z.number().optional().default(2).describe(". Type : Float"),
      Height: z.number().optional().default(2).describe(". Type : Float"),
      "Bottom Width": z
        .number()
        .optional()
        .default(4)
        .describe(". Type : Float"),
      "Top Width": z.number().optional().default(2).describe(". Type : Float"),
      Offset: z.number().optional().default(1).describe(". Type : Float"),
      "Bottom Height": z
        .number()
        .optional()
        .default(3)
        .describe(". Type : Float"),
      "Top Height": z.number().optional().default(1).describe(". Type : Float"),
      "Point 1": z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveSpiral: {
    description: "Adds a GeometryNodeCurveSpiral node to the graph.",
    parameters: z.object({
      Resolution: z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      Rotations: z.number().optional().default(2).describe(". Type : Float"),
      "Start Radius": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "End Radius": z.number().optional().default(2).describe(". Type : Float"),
      Height: z.number().optional().default(2).describe(". Type : Float"),
      Reverse: z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveStar: {
    description: "Adds a GeometryNodeCurveStar node to the graph.",
    parameters: z.object({
      Points: z.number().int().optional().default(8).describe(". Type : Int"),
      "Inner Radius": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Outer Radius": z
        .number()
        .optional()
        .default(2)
        .describe(". Type : Float"),
      Twist: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveSetHandles: {
    description: "Adds a GeometryNodeCurveSetHandles node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSplineParameter: {
    description: "Adds a GeometryNodeSplineParameter node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveSplineType: {
    description: "Adds a GeometryNodeCurveSplineType node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveToMesh: {
    description: "Adds a GeometryNodeCurveToMesh node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveToPoints: {
    description: "Adds a GeometryNodeCurveToPoints node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCurveOfPoint: {
    description: "Adds a GeometryNodeCurveOfPoint node to the graph.",
    parameters: z.object({
      "Point Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePointsOfCurve: {
    description: "Adds a GeometryNodePointsOfCurve node to the graph.",
    parameters: z.object({
      "Curve Index": z.number().int().optional().describe(". Type : Int"),
      Weights: z.number().optional().describe(". Type : Float"),
      "Sort Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDeformCurvesOnSurface: {
    description: "Adds a GeometryNodeDeformCurvesOnSurface node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDeleteGeometry: {
    description: "Adds a GeometryNodeDeleteGeometry node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDistributePointsInGrid: {
    description: "Adds a GeometryNodeDistributePointsInGrid node to the graph.",
    parameters: z.object({
      Grid: z.number().optional().describe(". Type : Float"),
      Density: z.number().optional().default(1).describe(". Type : Float"),
      Seed: z.number().int().optional().describe(". Type : Int"),
      Spacing: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDistributePointsInVolume: {
    description:
      "Adds a GeometryNodeDistributePointsInVolume node to the graph.",
    parameters: z.object({
      Density: z.number().optional().default(1).describe(". Type : Float"),
      Seed: z.number().int().optional().describe(". Type : Int"),
      Spacing: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDistributePointsOnFaces: {
    description:
      "Adds a GeometryNodeDistributePointsOnFaces node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDualMesh: {
    description: "Adds a GeometryNodeDualMesh node to the graph.",
    parameters: z.object({
      "Keep Boundaries": z
        .boolean()
        .optional()
        .default(false)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeDuplicateElements: {
    description: "Adds a GeometryNodeDuplicateElements node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Amount: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeEdgePathsToCurves: {
    description: "Adds a GeometryNodeEdgePathsToCurves node to the graph.",
    parameters: z.object({
      "Start Vertices": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
      "Next Vertex Index": z
        .number()
        .int()
        .optional()
        .default(-1)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeEdgePathsToSelection: {
    description: "Adds a GeometryNodeEdgePathsToSelection node to the graph.",
    parameters: z.object({
      "Start Vertices": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
      "Next Vertex Index": z
        .number()
        .int()
        .optional()
        .default(-1)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeEdgesToFaceGroups: {
    description: "Adds a GeometryNodeEdgesToFaceGroups node to the graph.",
    parameters: z.object({
      "Boundary Edges": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFieldAtIndex: {
    description: "Adds a GeometryNodeFieldAtIndex node to the graph.",
    parameters: z.object({
      Index: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFieldOnDomain: {
    description: "Adds a GeometryNodeFieldOnDomain node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeExtrudeMesh: {
    description: "Adds a GeometryNodeExtrudeMesh node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Offset: z.array(z.number()).optional().describe(". Type : Vector"),
      "Offset Scale": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      Individual: z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFillCurve: {
    description: "Adds a GeometryNodeFillCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFilletCurve: {
    description: "Adds a GeometryNodeFilletCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFlipFaces: {
    description: "Adds a GeometryNodeFlipFaces node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeGeometryToInstance: {
    description: "Adds a GeometryNodeGeometryToInstance node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeGetNamedGrid: {
    description: "Adds a GeometryNodeGetNamedGrid node to the graph.",
    parameters: z.object({
      Name: z.string().optional().describe(". Type : String"),
      Remove: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeGridToMesh: {
    description: "Adds a GeometryNodeGridToMesh node to the graph.",
    parameters: z.object({
      Grid: z.number().optional().describe(". Type : Float"),
      Threshold: z
        .number()
        .optional()
        .default(0.1)
        .describe(
          "Values larger than the threshold are inside the generated mesh. Type : Float"
        ),
      Adaptivity: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeImageInfo: {
    description: "Adds a GeometryNodeImageInfo node to the graph.",
    parameters: z.object({
      Frame: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeImageTexture: {
    description: "Adds a GeometryNodeImageTexture node to the graph.",
    parameters: z.object({
      Vector: z.array(z.number()).optional().describe(". Type : Vector"),
      Frame: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputImage: {
    description: "Adds a GeometryNodeInputImage node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeImportSTL: {
    description: "Adds a GeometryNodeImportSTL node to the graph.",
    parameters: z.object({
      Path: z
        .string()
        .optional()
        .default("")
        .describe("Path to a STL file. Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeIndexOfNearest: {
    description: "Adds a GeometryNodeIndexOfNearest node to the graph.",
    parameters: z.object({
      Position: z.array(z.number()).optional().describe(". Type : Vector"),
      "Group ID": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeIndexSwitch: {
    description: "Adds a GeometryNodeIndexSwitch node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputActiveCamera: {
    description: "Adds a GeometryNodeInputActiveCamera node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputCurveHandlePositions: {
    description:
      "Adds a GeometryNodeInputCurveHandlePositions node to the graph.",
    parameters: z.object({
      Relative: z.boolean().optional().default(false).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputCurveTilt: {
    description: "Adds a GeometryNodeInputCurveTilt node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputEdgeSmooth: {
    description: "Adds a GeometryNodeInputEdgeSmooth node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputShadeSmooth: {
    description: "Adds a GeometryNodeInputShadeSmooth node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputID: {
    description: "Adds a GeometryNodeInputID node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputIndex: {
    description: "Adds a GeometryNodeInputIndex node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputInstanceRotation: {
    description: "Adds a GeometryNodeInputInstanceRotation node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputInstanceScale: {
    description: "Adds a GeometryNodeInputInstanceScale node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMaterialIndex: {
    description: "Adds a GeometryNodeInputMaterialIndex node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInstanceTransform: {
    description: "Adds a GeometryNodeInstanceTransform node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMaterial: {
    description: "Adds a GeometryNodeInputMaterial node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshEdgeAngle: {
    description: "Adds a GeometryNodeInputMeshEdgeAngle node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshEdgeNeighbors: {
    description: "Adds a GeometryNodeInputMeshEdgeNeighbors node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshEdgeVertices: {
    description: "Adds a GeometryNodeInputMeshEdgeVertices node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshFaceArea: {
    description: "Adds a GeometryNodeInputMeshFaceArea node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshFaceIsPlanar: {
    description: "Adds a GeometryNodeInputMeshFaceIsPlanar node to the graph.",
    parameters: z.object({
      Threshold: z.number().optional().default(0.01).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshFaceNeighbors: {
    description: "Adds a GeometryNodeInputMeshFaceNeighbors node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshIsland: {
    description: "Adds a GeometryNodeInputMeshIsland node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputMeshVertexNeighbors: {
    description:
      "Adds a GeometryNodeInputMeshVertexNeighbors node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputNamedAttribute: {
    description: "Adds a GeometryNodeInputNamedAttribute node to the graph.",
    parameters: z.object({
      Name: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputNamedLayerSelection: {
    description:
      "Adds a GeometryNodeInputNamedLayerSelection node to the graph.",
    parameters: z.object({
      Name: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputNormal: {
    description: "Adds a GeometryNodeInputNormal node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputPosition: {
    description: "Adds a GeometryNodeInputPosition node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputRadius: {
    description: "Adds a GeometryNodeInputRadius node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputSceneTime: {
    description: "Adds a GeometryNodeInputSceneTime node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputShortestEdgePaths: {
    description: "Adds a GeometryNodeInputShortestEdgePaths node to the graph.",
    parameters: z.object({
      "End Vertex": z
        .boolean()
        .optional()
        .default(false)
        .describe(". Type : Bool"),
      "Edge Cost": z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputSplineCyclic: {
    description: "Adds a GeometryNodeInputSplineCyclic node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSplineLength: {
    description: "Adds a GeometryNodeSplineLength node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputSplineResolution: {
    description: "Adds a GeometryNodeInputSplineResolution node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInputTangent: {
    description: "Adds a GeometryNodeInputTangent node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInstanceOnPoints: {
    description: "Adds a GeometryNodeInstanceOnPoints node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInstancesToPoints: {
    description: "Adds a GeometryNodeInstancesToPoints node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Position: z.array(z.number()).optional().describe(". Type : Vector"),
      Radius: z.number().optional().default(0.05).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeInterpolateCurves: {
    description: "Adds a GeometryNodeInterpolateCurves node to the graph.",
    parameters: z.object({
      "Guide Up": z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeIsViewport: {
    description: "Adds a GeometryNodeIsViewport node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeJoinGeometry: {
    description: "Adds a GeometryNodeJoinGeometry node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMaterialSelection: {
    description: "Adds a GeometryNodeMaterialSelection node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMenuSwitch: {
    description: "Adds a GeometryNodeMenuSwitch node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMergeByDistance: {
    description: "Adds a GeometryNodeMergeByDistance node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshBoolean: {
    description: "Adds a GeometryNodeMeshBoolean node to the graph.",
    parameters: z.object({
      "Self Intersection": z.boolean().optional().describe(". Type : Bool"),
      "Hole Tolerant": z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshFaceSetBoundaries: {
    description: "Adds a GeometryNodeMeshFaceSetBoundaries node to the graph.",
    parameters: z.object({
      "Face Set": z
        .number()
        .int()
        .optional()
        .default(0)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshCircle: {
    description: "Adds a GeometryNodeMeshCircle node to the graph.",
    parameters: z.object({
      Vertices: z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      Radius: z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshCone: {
    description: "Adds a GeometryNodeMeshCone node to the graph.",
    parameters: z.object({
      Vertices: z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      "Side Segments": z
        .number()
        .int()
        .optional()
        .default(1)
        .describe(". Type : Int"),
      "Fill Segments": z
        .number()
        .int()
        .optional()
        .default(1)
        .describe(". Type : Int"),
      "Radius Top": z.number().optional().describe(". Type : Float"),
      "Radius Bottom": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      Depth: z.number().optional().default(2).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshCube: {
    description: "Adds a GeometryNodeMeshCube node to the graph.",
    parameters: z.object({
      Size: z
        .array(z.number())
        .optional()
        .default([1, 1, 1])
        .describe(". Type : Vector"),
      "Vertices X": z
        .number()
        .int()
        .optional()
        .default(2)
        .describe(". Type : Int"),
      "Vertices Y": z
        .number()
        .int()
        .optional()
        .default(2)
        .describe(". Type : Int"),
      "Vertices Z": z
        .number()
        .int()
        .optional()
        .default(2)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshCylinder: {
    description: "Adds a GeometryNodeMeshCylinder node to the graph.",
    parameters: z.object({
      Vertices: z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      "Side Segments": z
        .number()
        .int()
        .optional()
        .default(1)
        .describe(". Type : Int"),
      "Fill Segments": z
        .number()
        .int()
        .optional()
        .default(1)
        .describe(". Type : Int"),
      Radius: z.number().optional().default(1).describe(". Type : Float"),
      Depth: z.number().optional().default(2).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshGrid: {
    description: "Adds a GeometryNodeMeshGrid node to the graph.",
    parameters: z.object({
      "Size X": z.number().optional().default(1).describe(". Type : Float"),
      "Size Y": z.number().optional().default(1).describe(". Type : Float"),
      "Vertices X": z
        .number()
        .int()
        .optional()
        .default(3)
        .describe(". Type : Int"),
      "Vertices Y": z
        .number()
        .int()
        .optional()
        .default(3)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshIcoSphere: {
    description: "Adds a GeometryNodeMeshIcoSphere node to the graph.",
    parameters: z.object({
      Radius: z.number().optional().default(1).describe(". Type : Float"),
      Subdivisions: z
        .number()
        .int()
        .optional()
        .default(1)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshLine: {
    description: "Adds a GeometryNodeMeshLine node to the graph.",
    parameters: z.object({
      Count: z.number().int().optional().default(10).describe(". Type : Int"),
      Resolution: z.number().optional().default(1).describe(". Type : Float"),
      "Start Location": z
        .array(z.number())
        .optional()
        .describe(". Type : Vector"),
      Offset: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshUVSphere: {
    description: "Adds a GeometryNodeMeshUVSphere node to the graph.",
    parameters: z.object({
      Segments: z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      Rings: z.number().int().optional().default(16).describe(". Type : Int"),
      Radius: z.number().optional().default(1).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshToCurve: {
    description: "Adds a GeometryNodeMeshToCurve node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshToDensityGrid: {
    description: "Adds a GeometryNodeMeshToDensityGrid node to the graph.",
    parameters: z.object({
      Density: z.number().optional().default(1).describe(". Type : Float"),
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
      "Gradient Width": z
        .number()
        .optional()
        .default(0.2)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshToPoints: {
    description: "Adds a GeometryNodeMeshToPoints node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Position: z.array(z.number()).optional().describe(". Type : Vector"),
      Radius: z.number().optional().default(0.05).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshToSDFGrid: {
    description: "Adds a GeometryNodeMeshToSDFGrid node to the graph.",
    parameters: z.object({
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
      "Band Width": z
        .number()
        .int()
        .optional()
        .default(3)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeMeshToVolume: {
    description: "Adds a GeometryNodeMeshToVolume node to the graph.",
    parameters: z.object({
      Density: z.number().optional().default(1).describe(". Type : Float"),
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
      "Voxel Amount": z
        .number()
        .optional()
        .default(64)
        .describe(". Type : Float"),
      "Interior Band Width": z
        .number()
        .optional()
        .default(0.2)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCornersOfEdge: {
    description: "Adds a GeometryNodeCornersOfEdge node to the graph.",
    parameters: z.object({
      "Edge Index": z.number().int().optional().describe(". Type : Int"),
      Weights: z.number().optional().describe(". Type : Float"),
      "Sort Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCornersOfFace: {
    description: "Adds a GeometryNodeCornersOfFace node to the graph.",
    parameters: z.object({
      "Face Index": z.number().int().optional().describe(". Type : Int"),
      Weights: z.number().optional().describe(". Type : Float"),
      "Sort Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeCornersOfVertex: {
    description: "Adds a GeometryNodeCornersOfVertex node to the graph.",
    parameters: z.object({
      "Vertex Index": z.number().int().optional().describe(". Type : Int"),
      Weights: z.number().optional().describe(". Type : Float"),
      "Sort Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeEdgesOfCorner: {
    description: "Adds a GeometryNodeEdgesOfCorner node to the graph.",
    parameters: z.object({
      "Corner Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeEdgesOfVertex: {
    description: "Adds a GeometryNodeEdgesOfVertex node to the graph.",
    parameters: z.object({
      "Vertex Index": z.number().int().optional().describe(". Type : Int"),
      Weights: z.number().optional().describe(". Type : Float"),
      "Sort Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeFaceOfCorner: {
    description: "Adds a GeometryNodeFaceOfCorner node to the graph.",
    parameters: z.object({
      "Corner Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeOffsetCornerInFace: {
    description: "Adds a GeometryNodeOffsetCornerInFace node to the graph.",
    parameters: z.object({
      "Corner Index": z.number().int().optional().describe(". Type : Int"),
      Offset: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeVertexOfCorner: {
    description: "Adds a GeometryNodeVertexOfCorner node to the graph.",
    parameters: z.object({
      "Corner Index": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeObjectInfo: {
    description: "Adds a GeometryNodeObjectInfo node to the graph.",
    parameters: z.object({
      "As Instance": z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeOffsetPointInCurve: {
    description: "Adds a GeometryNodeOffsetPointInCurve node to the graph.",
    parameters: z.object({
      "Point Index": z.number().int().optional().describe(". Type : Int"),
      Offset: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePointsToCurves: {
    description: "Adds a GeometryNodePointsToCurves node to the graph.",
    parameters: z.object({
      "Curve Group ID": z.number().int().optional().describe(". Type : Int"),
      Weight: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePointsToSDFGrid: {
    description: "Adds a GeometryNodePointsToSDFGrid node to the graph.",
    parameters: z.object({
      Radius: z.number().optional().default(0.5).describe(". Type : Float"),
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePointsToVertices: {
    description: "Adds a GeometryNodePointsToVertices node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePointsToVolume: {
    description: "Adds a GeometryNodePointsToVolume node to the graph.",
    parameters: z.object({
      Density: z.number().optional().default(1).describe(". Type : Float"),
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodePoints: {
    description: "Adds a GeometryNodePoints node to the graph.",
    parameters: z.object({
      Count: z.number().int().optional().default(1).describe(". Type : Int"),
      Position: z
        .array(z.number())
        .optional()
        .default([0, 0, 0])
        .describe(". Type : Vector"),
      Radius: z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeProximity: {
    description: "Adds a GeometryNodeProximity node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeRaycast: {
    description: "Adds a GeometryNodeRaycast node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeRealizeInstances: {
    description: "Adds a GeometryNodeRealizeInstances node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Realize All": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
      Depth: z.number().int().optional().default(0).describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeRemoveAttribute: {
    description: "Adds a GeometryNodeRemoveAttribute node to the graph.",
    parameters: z.object({
      Name: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeReplaceMaterial: {
    description: "Adds a GeometryNodeReplaceMaterial node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeResampleCurve: {
    description: "Adds a GeometryNodeResampleCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeReverseCurve: {
    description: "Adds a GeometryNodeReverseCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeRotateInstances: {
    description: "Adds a GeometryNodeRotateInstances node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Pivot Point": z.array(z.number()).optional().describe(". Type : Vector"),
      "Local Space": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleCurve: {
    description: "Adds a GeometryNodeSampleCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleGrid: {
    description: "Adds a GeometryNodeSampleGrid node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleGridIndex: {
    description: "Adds a GeometryNodeSampleGridIndex node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleIndex: {
    description: "Adds a GeometryNodeSampleIndex node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleNearestSurface: {
    description: "Adds a GeometryNodeSampleNearestSurface node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleNearest: {
    description: "Adds a GeometryNodeSampleNearest node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSampleUVSurface: {
    description: "Adds a GeometryNodeSampleUVSurface node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeScaleElements: {
    description: "Adds a GeometryNodeScaleElements node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Scale: z.number().optional().default(1).describe(". Type : Float"),
      Center: z.array(z.number()).optional().describe(". Type : Vector"),
      Axis: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeScaleInstances: {
    description: "Adds a GeometryNodeScaleInstances node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Scale: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSDFGridBoolean: {
    description: "Adds a GeometryNodeSDFGridBoolean node to the graph.",
    parameters: z.object({
      "Grid 1": z.number().optional().describe(". Type : Float"),
      "Grid 2": z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSelfObject: {
    description: "Adds a GeometryNodeSelfObject node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSeparateComponents: {
    description: "Adds a GeometryNodeSeparateComponents node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSeparateGeometry: {
    description: "Adds a GeometryNodeSeparateGeometry node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetCurveHandlePositions: {
    description:
      "Adds a GeometryNodeSetCurveHandlePositions node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Position: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetCurveNormal: {
    description: "Adds a GeometryNodeSetCurveNormal node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetCurveRadius: {
    description: "Adds a GeometryNodeSetCurveRadius node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetCurveTilt: {
    description: "Adds a GeometryNodeSetCurveTilt node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetID: {
    description: "Adds a GeometryNodeSetID node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      ID: z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetMaterialIndex: {
    description: "Adds a GeometryNodeSetMaterialIndex node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetMaterial: {
    description: "Adds a GeometryNodeSetMaterial node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetPointRadius: {
    description: "Adds a GeometryNodeSetPointRadius node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Radius: z.number().optional().default(0.05).describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetPosition: {
    description: "Adds a GeometryNodeSetPosition node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Position: z.array(z.number()).optional().describe(". Type : Vector"),
      Offset: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetShadeSmooth: {
    description: "Adds a GeometryNodeSetShadeSmooth node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Shade Smooth": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetSplineCyclic: {
    description: "Adds a GeometryNodeSetSplineCyclic node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetSplineResolution: {
    description: "Adds a GeometryNodeSetSplineResolution node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSetInstanceTransform: {
    description: "Adds a GeometryNodeSetInstanceTransform node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSortElements: {
    description: "Adds a GeometryNodeSortElements node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Group ID": z.number().int().optional().describe(". Type : Int"),
      "Sort Weight": z.number().optional().describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSplitEdges: {
    description: "Adds a GeometryNodeSplitEdges node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSplitToInstances: {
    description: "Adds a GeometryNodeSplitToInstances node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeStoreNamedAttribute: {
    description: "Adds a GeometryNodeStoreNamedAttribute node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Name: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeStoreNamedGrid: {
    description: "Adds a GeometryNodeStoreNamedGrid node to the graph.",
    parameters: z.object({
      Name: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeStringJoin: {
    description: "Adds a GeometryNodeStringJoin node to the graph.",
    parameters: z.object({
      Delimiter: z.string().optional().describe(". Type : String"),
      Strings: z.string().optional().describe(". Type : String"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeStringToCurves: {
    description: "Adds a GeometryNodeStringToCurves node to the graph.",
    parameters: z.object({
      String: z.string().optional().describe(". Type : String"),
      Size: z.number().optional().default(1).describe(". Type : Float"),
      "Character Spacing": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Word Spacing": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Line Spacing": z
        .number()
        .optional()
        .default(1)
        .describe(". Type : Float"),
      "Text Box Width": z
        .number()
        .optional()
        .default(0)
        .describe(". Type : Float"),
      "Text Box Height": z
        .number()
        .optional()
        .default(0)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSubdivideCurve: {
    description: "Adds a GeometryNodeSubdivideCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSubdivideMesh: {
    description: "Adds a GeometryNodeSubdivideMesh node to the graph.",
    parameters: z.object({
      Level: z.number().int().optional().default(1).describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSubdivisionSurface: {
    description: "Adds a GeometryNodeSubdivisionSurface node to the graph.",
    parameters: z.object({
      Level: z.number().int().optional().default(1).describe(". Type : Int"),
      "Edge Crease": z
        .number()
        .optional()
        .default(0)
        .describe(". Type : Float"),
      "Vertex Crease": z
        .number()
        .optional()
        .default(0)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeSwitch: {
    description: "Adds a GeometryNodeSwitch node to the graph.",
    parameters: z.object({
      Switch: z.boolean().optional().describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeTool3DCursor: {
    description: "Adds a GeometryNodeTool3DCursor node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolFaceSet: {
    description: "Adds a GeometryNodeToolFaceSet node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolMousePosition: {
    description: "Adds a GeometryNodeToolMousePosition node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolSelection: {
    description: "Adds a GeometryNodeToolSelection node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolActiveElement: {
    description: "Adds a GeometryNodeToolActiveElement node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolSetFaceSet: {
    description: "Adds a GeometryNodeToolSetFaceSet node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Face Set": z.number().int().optional().describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeToolSetSelection: {
    description: "Adds a GeometryNodeToolSetSelection node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeViewportTransform: {
    description: "Adds a GeometryNodeViewportTransform node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeTransform: {
    description: "Adds a GeometryNodeTransform node to the graph.",
    parameters: z.object({
      Translation: z.array(z.number()).optional().describe(". Type : Vector"),
      Scale: z.array(z.number()).optional().describe(". Type : Vector"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeTranslateInstances: {
    description: "Adds a GeometryNodeTranslateInstances node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Translation: z.array(z.number()).optional().describe(". Type : Vector"),
      "Local Space": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeTriangulate: {
    description: "Adds a GeometryNodeTriangulate node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      "Minimum Vertices": z
        .number()
        .int()
        .optional()
        .default(4)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeTrimCurve: {
    description: "Adds a GeometryNodeTrimCurve node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeUVPackIslands: {
    description: "Adds a GeometryNodeUVPackIslands node to the graph.",
    parameters: z.object({
      UV: z.array(z.number()).optional().describe(". Type : Vector"),
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Margin: z.number().optional().default(0.001).describe(". Type : Float"),
      Rotate: z
        .boolean()
        .optional()
        .default(true)
        .describe("Rotate islands for best fit. Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeUVUnwrap: {
    description: "Adds a GeometryNodeUVUnwrap node to the graph.",
    parameters: z.object({
      Selection: z.boolean().optional().default(true).describe(". Type : Bool"),
      Seam: z.boolean().optional().describe(". Type : Bool"),
      Margin: z.number().optional().default(0.001).describe(". Type : Float"),
      "Fill Holes": z
        .boolean()
        .optional()
        .default(true)
        .describe(". Type : Bool"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeViewer: {
    description: "Adds a GeometryNodeViewer node to the graph.",
    parameters: z.object({}),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeVolumeCube: {
    description: "Adds a GeometryNodeVolumeCube node to the graph.",
    parameters: z.object({
      Density: z
        .number()
        .optional()
        .default(1)
        .describe("Volume density per voxel. Type : Float"),
      Background: z
        .number()
        .optional()
        .describe("Value for voxels outside of the cube. Type : Float"),
      Min: z
        .array(z.number())
        .optional()
        .default([-1, -1, -1])
        .describe(". Type : Vector"),
      Max: z
        .array(z.number())
        .optional()
        .default([1, 1, 1])
        .describe(". Type : Vector"),
      "Resolution X": z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      "Resolution Y": z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
      "Resolution Z": z
        .number()
        .int()
        .optional()
        .default(32)
        .describe(". Type : Int"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },

  addGeometryNodeVolumeToMesh: {
    description: "Adds a GeometryNodeVolumeToMesh node to the graph.",
    parameters: z.object({
      "Voxel Size": z
        .number()
        .optional()
        .default(0.3)
        .describe(". Type : Float"),
    }),
    returns: _OperationResponse.extend({ nodeId: z.string() }),
  },
};

const geometryAtomicTools = {
  ...autoGeneratedAtomicTools,
  createGeometry: {
    description:
      "Creates a new geometry object. Starting point for every geometry creation. \
      The geometry is built using a node graph. \
      The node graph output is already added in the node graph, and its id is 'Group Output'. \
      Its input port 'Mesh' is the output of the geometry.",
    parameters: z.object({
      id: z.string().describe("Object identifier. Must be unique."),
    }),
    returns: _OperationResponse,
  },
  startEditGeometry: {
    description: "Starts editing the geometry of an object.",
    parameters: z.object({
      id: z.string().describe("Object identifier"),
    }),
    returns: _OperationResponse,
  },
  endEditGeometry: {
    description: "Ends the current editing of the geometry of an object.",
    parameters: z.object({}),
    returns: _OperationResponse,
  },
  // addNodeMeshCube: {
  //   description: "Adds a new mesh cube node to the current edited geometry.",
  //   parameters: z.object({
  //     Size: z.array(z.number()).length(3).default([1, 1, 1]).optional(),
  //     Vertices_X: z.number().int().default(2).optional(),
  //     Vertices_Y: z.number().int().default(2).optional(),
  //     Vertices_Z: z.number().int().default(2).optional(),
  //   }),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeMeshCylinder: {
  //   description:
  //     "Adds a new mesh cylinder node to the current edited geometry.",
  //   parameters: z.object({
  //     Vertices: z.number().int().default(32).optional(),
  //     Radius: z.number().default(1).optional(),
  //     Depth: z.number().default(2).optional(),
  //     Side_Segments: z.number().int().default(1).optional(),
  //     Fill_Segments: z.number().int().default(1).optional(),
  //   }),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeMeshUVSphere: {
  //   description: "Adds a new mesh sphere node to the current edited geometry.",
  //   parameters: z.object({
  //     Radius: z.number().default(1).optional(),
  //     Rings: z.number().int().default(16).optional(),
  //     Segments: z.number().int().default(32).optional(),
  //   }),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeMeshCone: {
  //   description: "Adds a new mesh cone node to the current edited geometry.",
  //   parameters: z.object({
  //     Vertices: z.number().int().default(32).optional(),
  //     Radius_Top: z.number().default(0).optional(),
  //     Radius_Bottom: z.number().default(1).optional(),
  //     Depth: z.number().default(2).optional(),
  //     Side_Segments: z.number().int().default(1).optional(),
  //     Fill_Segments: z.number().int().default(1).optional(),
  //   }),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeSetPosition: {
  //   description: "Adds a new set position node to the current edited geometry.",
  //   parameters: z.object({}),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodePositionInput: {
  //   description:
  //     "Adds a new position input node to the current edited geometry.",
  //   parameters: z.object({}),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeMath: {
  //   description: "Adds a new math node to the current edited geometry.",
  //   parameters: z.object({
  //     operation: z
  //       .enum([
  //         "ADD",
  //         "SUBTRACT",
  //         "MULTIPLY",
  //         "DIVIDE",
  //         "MULTIPLY_ADD",
  //         "POWER",
  //         "LOGARITHM",
  //         "SQRT",
  //         "INVERSE_SQRT",
  //         "ABSOLUTE",
  //         "EXPONENT",
  //         "MINIMUM",
  //         "MAXIMUM",
  //         "LESS_THAN",
  //         "GREATER_THAN",
  //         "SIGN",
  //         "COMPARE",
  //         "SMOOTH_MIN",
  //         "SMOOTH_MAX",
  //         "ROUND",
  //         "FLOOR",
  //         "CEIL",
  //         "TRUNC",
  //         "FRACT",
  //         "MODULO",
  //         "FLOORED_MODULO",
  //         "WRAP",
  //         "SNAP",
  //         "PINGPONG",
  //         "SINE",
  //         "COSINE",
  //         "TANGENT",
  //         "ARCSINE",
  //         "ARCCOSINE",
  //         "ARCTANGENT",
  //         "ARCTAN2",
  //         "SINH",
  //         "COSH",
  //         "TANH",
  //         "RADIANS",
  //         "DEGREES",
  //       ])
  //       .describe("Math operation"),
  //   }),
  //   returns: _OperationResponse,
  // },
  // addNodeSeparateXYZ: {
  //   description: "Adds a new separate XYZ node to the current edited geometry.",
  //   parameters: z.object({}),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  // addNodeCombineXYZ: {
  //   description: "Adds a new combine XYZ node to the current edited geometry.",
  //   parameters: z.object({}),
  //   returns: _OperationResponse.extend({
  //     nodeId: z.string().describe("Created node identifier"),
  //     inputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //         can_accept_default_value: z.boolean(),
  //       })
  //       .describe("Node inputs"),
  //     outputs: z
  //       .object({
  //         name: z.string(),
  //         type: z.string(),
  //       })
  //       .describe("Node outputs"),
  //   }),
  // },
  setNodePropertyByIndex: {
    description:
      "Sets an input default value of a node. For the available inputs and their type, use 'getNodeInputsOutputs'. Note that vectors are written Vector(x, y, z)",
    parameters: z.object({
      nodeId: z.string().describe("Node identifier"),
      propertyIndex: z
        .number()
        .describe("Index of the property in the list of inputs"),
      value: z.string().describe("Property value"),
    }),
    returns: _OperationResponse,
  },
  // getNodeTypes: {
  //   description:
  //     "Returns all available node types that can be added to a geometry",
  //   parameters: z.object({}),
  //   returns: _OperationResponse.extend({
  //     nodeTypes: z.array(z.string()),
  //   }),
  // },
  getNodeInputsOutputs: {
    description:
      "Retrieves all input and output socket names for a node, and checks if input sockets can accept a default_value.",
    parameters: z.object({
      nodeId: z
        .string()
        .describe(
          "The node id to get information about, must exist in the node graph"
        ),
    }),
    returns: _OperationResponse.extend({
      inputs: z
        .object({
          name: z.string(),
          type: z.string(),
          can_accept_default_value: z.boolean(),
        })
        .describe("Node inputs"),
      outputs: z
        .object({
          name: z.string(),
          type: z.string(),
        })
        .describe("Node outputs"),
    }),
  },
  // addNodesBatch: {
  //   description:
  //     'Adds a batch of nodes to the current edited geometry. The nodes are added in the order they are provided. \
  //     the node format is {"type": <node_type>, "inputs": {<input_name>: <value>, ...}}',
  //   parameters: z.object({
  //     nodes: z.array(blNodeType).describe("List of nodes to add"),
  //   }),
  //   returns: _OperationResponse.extend({
  //     nodes: z.array(z.object({})).describe("Created nodes"),
  //   }),
  // },
  connectNodesBatch: {
    description:
      "Connects a batch of nodes in the current edited geometry. The connections are made in the order they are provided.",
    parameters: z.object({
      nodes: z
        .array(
          z.object({
            fromNode: z.string().describe("Node identifier"),
            fromPort: z.string().describe("Port name"),
            toNode: z.string().describe("Node identifier"),
            toPort: z.string().describe("Port name"),
          })
        )
        .describe("List of connections to make"),
    }),
    returns: _OperationResponse,
  },
} as const;

export type GeometryTool = keyof typeof geometryAtomicTools;

const geometryAtomicToolsWithExecute =
  createExecutableTools(geometryAtomicTools);

export { geometryAtomicToolsWithExecute };

const NODE_LIST = [
  { name: "GeometryNodeAttributeStatistic" },
  { name: "GeometryNodeAttributeDomainSize" },
  { name: "GeometryNodeBlurAttribute" },
  { name: "GeometryNodeCaptureAttribute" },
  { name: "GeometryNodeRemoveAttribute" },
  { name: "GeometryNodeStoreNamedAttribute" },
  { name: "ShaderNodeBlackbody" },
  { name: "ShaderNodeValToRGB" },
  { name: "ShaderNodeRGBCurve" },
  { name: "FunctionNodeCombineColor" },
  { name: "ShaderNodeMix" },
  { name: "FunctionNodeSeparateColor" },
  { name: "GeometryNodeInputCurveHandlePositions" },
  { name: "GeometryNodeCurveLength" },
  { name: "GeometryNodeInputTangent" },
  { name: "GeometryNodeInputCurveTilt" },
  { name: "GeometryNodeCurveEndpointSelection" },
  { name: "GeometryNodeCurveHandleTypeSelection" },
  { name: "GeometryNodeInputSplineCyclic" },
  { name: "GeometryNodeSplineLength" },
  { name: "GeometryNodeSplineParameter" },
  { name: "GeometryNodeInputSplineResolution" },
  { name: "GeometryNodeSampleCurve" },
  { name: "GeometryNodeSetCurveNormal" },
  { name: "GeometryNodeSetCurveRadius" },
  { name: "GeometryNodeSetCurveTilt" },
  { name: "GeometryNodeSetCurveHandlePositions" },
  { name: "GeometryNodeCurveSetHandles" },
  { name: "GeometryNodeSetSplineCyclic" },
  { name: "GeometryNodeSetSplineResolution" },
  { name: "GeometryNodeCurveSplineType" },
  { name: "GeometryNodeCurveToMesh" },
  { name: "GeometryNodeCurveToPoints" },
  { name: "GeometryNodeDeformCurvesOnSurface" },
  { name: "GeometryNodeFillCurve" },
  { name: "GeometryNodeFilletCurve" },
  { name: "GeometryNodeInterpolateCurves" },
  { name: "GeometryNodeResampleCurve" },
  { name: "GeometryNodeReverseCurve" },
  { name: "GeometryNodeSubdivideCurve" },
  { name: "GeometryNodeTrimCurve" },
  { name: "GeometryNodeCurveArc" },
  { name: "GeometryNodeCurvePrimitiveBezierSegment" },
  { name: "GeometryNodeCurvePrimitiveCircle" },
  { name: "GeometryNodeCurvePrimitiveLine" },
  { name: "GeometryNodeCurveSpiral" },
  { name: "GeometryNodeCurveQuadraticBezier" },
  { name: "GeometryNodeCurvePrimitiveQuadrilateral" },
  { name: "GeometryNodeCurveStar" },
  { name: "GeometryNodeCurveOfPoint" },
  { name: "GeometryNodeOffsetPointInCurve" },
  { name: "GeometryNodePointsOfCurve" },
  { name: "GeometryNodeGeometryToInstance" },
  { name: "GeometryNodeJoinGeometry" },
  { name: "GeometryNodeInputID" },
  { name: "GeometryNodeInputIndex" },
  { name: "GeometryNodeInputNamedAttribute" },
  { name: "GeometryNodeInputNormal" },
  { name: "GeometryNodeInputPosition" },
  { name: "GeometryNodeInputRadius" },
  { name: "GeometryNodeToolSelection" },
  { name: "GeometryNodeToolActiveElement" },
  { name: "GeometryNodeSetID" },
  { name: "GeometryNodeSetPosition" },
  { name: "GeometryNodeToolSetSelection" },
  { name: "GeometryNodeBake" },
  { name: "GeometryNodeBoundBox" },
  { name: "GeometryNodeConvexHull" },
  { name: "GeometryNodeDeleteGeometry" },
  { name: "GeometryNodeDuplicateElements" },
  { name: "GeometryNodeMergeByDistance" },
  { name: "GeometryNodeSortElements" },
  { name: "GeometryNodeTransform" },
  { name: "GeometryNodeSeparateComponents" },
  { name: "GeometryNodeSeparateGeometry" },
  { name: "GeometryNodeSplitToInstances" },
  { name: "GeometryNodeProximity" },
  { name: "GeometryNodeIndexOfNearest" },
  { name: "GeometryNodeRaycast" },
  { name: "GeometryNodeSampleIndex" },
  { name: "GeometryNodeSampleNearest" },
  { name: "FunctionNodeInputBool" },
  { name: "FunctionNodeInputColor" },
  { name: "GeometryNodeInputImage" },
  { name: "FunctionNodeInputInt" },
  { name: "GeometryNodeInputMaterial" },
  { name: "FunctionNodeInputRotation" },
  { name: "FunctionNodeInputString" },
  { name: "ShaderNodeValue" },
  { name: "FunctionNodeInputVector" },
  { name: "NodeGroupInput" },
  { name: "GeometryNodeTool3DCursor" },
  { name: "GeometryNodeInputActiveCamera" },
  { name: "GeometryNodeCollectionInfo" },
  { name: "GeometryNodeImageInfo" },
  { name: "GeometryNodeIsViewport" },
  { name: "GeometryNodeInputNamedLayerSelection" },
  { name: "GeometryNodeToolMousePosition" },
  { name: "GeometryNodeObjectInfo" },
  { name: "GeometryNodeInputSceneTime" },
  { name: "GeometryNodeSelfObject" },
  { name: "GeometryNodeViewportTransform" },
  { name: "GeometryNodeInstanceOnPoints" },
  { name: "GeometryNodeInstancesToPoints" },
  { name: "GeometryNodeRealizeInstances" },
  { name: "GeometryNodeRotateInstances" },
  { name: "GeometryNodeScaleInstances" },
  { name: "GeometryNodeTranslateInstances" },
  { name: "GeometryNodeSetInstanceTransform" },
  { name: "GeometryNodeInstanceTransform" },
  { name: "GeometryNodeInputInstanceRotation" },
  { name: "GeometryNodeInputInstanceScale" },
  { name: "GeometryNodeReplaceMaterial" },
  { name: "GeometryNodeInputMaterialIndex" },
  { name: "GeometryNodeMaterialSelection" },
  { name: "GeometryNodeSetMaterial" },
  { name: "GeometryNodeSetMaterialIndex" },
  { name: "GeometryNodeInputMeshEdgeAngle" },
  { name: "GeometryNodeInputMeshEdgeNeighbors" },
  { name: "GeometryNodeInputMeshEdgeVertices" },
  { name: "GeometryNodeEdgesToFaceGroups" },
  { name: "GeometryNodeInputMeshFaceArea" },
  { name: "GeometryNodeMeshFaceSetBoundaries" },
  { name: "GeometryNodeInputMeshFaceNeighbors" },
  { name: "GeometryNodeToolFaceSet" },
  { name: "GeometryNodeInputMeshFaceIsPlanar" },
  { name: "GeometryNodeInputShadeSmooth" },
  { name: "GeometryNodeInputEdgeSmooth" },
  { name: "GeometryNodeInputMeshIsland" },
  { name: "GeometryNodeInputShortestEdgePaths" },
  { name: "GeometryNodeInputMeshVertexNeighbors" },
  { name: "GeometryNodeSampleNearestSurface" },
  { name: "GeometryNodeSampleUVSurface" },
  { name: "GeometryNodeToolSetFaceSet" },
  { name: "GeometryNodeSetShadeSmooth" },
  { name: "GeometryNodeDualMesh" },
  { name: "GeometryNodeEdgePathsToCurves" },
  { name: "GeometryNodeEdgePathsToSelection" },
  { name: "GeometryNodeExtrudeMesh" },
  { name: "GeometryNodeFlipFaces" },
  { name: "GeometryNodeMeshBoolean" },
  { name: "GeometryNodeMeshToCurve" },
  { name: "GeometryNodeMeshToDensityGrid" },
  { name: "GeometryNodeMeshToPoints" },
  { name: "GeometryNodeMeshToSDFGrid" },
  { name: "GeometryNodeMeshToVolume" },
  { name: "GeometryNodeScaleElements" },
  { name: "GeometryNodeSplitEdges" },
  { name: "GeometryNodeSubdivideMesh" },
  { name: "GeometryNodeSubdivisionSurface" },
  { name: "GeometryNodeTriangulate" },
  { name: "GeometryNodeMeshCone" },
  { name: "GeometryNodeMeshCube" },
  { name: "GeometryNodeMeshCylinder" },
  { name: "GeometryNodeMeshGrid" },
  { name: "GeometryNodeMeshIcoSphere" },
  { name: "GeometryNodeMeshCircle" },
  { name: "GeometryNodeMeshLine" },
  { name: "GeometryNodeMeshUVSphere" },
  { name: "GeometryNodeImportSTL" },
  { name: "GeometryNodeCornersOfEdge" },
  { name: "GeometryNodeCornersOfFace" },
  { name: "GeometryNodeCornersOfVertex" },
  { name: "GeometryNodeEdgesOfCorner" },
  { name: "GeometryNodeEdgesOfVertex" },
  { name: "GeometryNodeFaceOfCorner" },
  { name: "GeometryNodeOffsetCornerInFace" },
  { name: "GeometryNodeVertexOfCorner" },
  { name: "NodeGroupOutput" },
  { name: "GeometryNodeViewer" },
  { name: "GeometryNodeDistributePointsInVolume" },
  { name: "GeometryNodeDistributePointsInGrid" },
  { name: "GeometryNodeDistributePointsOnFaces" },
  { name: "GeometryNodePoints" },
  { name: "GeometryNodePointsToCurves" },
  { name: "GeometryNodePointsToSDFGrid" },
  { name: "GeometryNodePointsToVertices" },
  { name: "GeometryNodePointsToVolume" },
  { name: "GeometryNodeSetPointRadius" },
  { name: "GeometryNodeStringJoin" },
  { name: "FunctionNodeReplaceString" },
  { name: "FunctionNodeSliceString" },
  { name: "FunctionNodeStringLength" },
  { name: "GeometryNodeStringToCurves" },
  { name: "FunctionNodeValueToString" },
  { name: "FunctionNodeInputSpecialCharacters" },
  { name: "ShaderNodeTexBrick" },
  { name: "ShaderNodeTexChecker" },
  { name: "ShaderNodeTexGradient" },
  { name: "GeometryNodeImageTexture" },
  { name: "ShaderNodeTexMagic" },
  { name: "ShaderNodeTexNoise" },
  { name: "ShaderNodeTexVoronoi" },
  { name: "ShaderNodeTexWave" },
  { name: "ShaderNodeTexWhiteNoise" },
  { name: "GeometryNodeIndexSwitch" },
  { name: "GeometryNodeMenuSwitch" },
  { name: "FunctionNodeRandomValue" },
  { name: "GeometryNodeSwitch" },
  { name: "FunctionNodeAlignEulerToVector" },
  { name: "FunctionNodeRotateEuler" },
  { name: "GeometryNodeAccumulateField" },
  { name: "GeometryNodeFieldAtIndex" },
  { name: "GeometryNodeFieldOnDomain" },
  { name: "FunctionNodeAlignRotationToVector" },
  { name: "FunctionNodeAxesToRotation" },
  { name: "FunctionNodeAxisAngleToRotation" },
  { name: "FunctionNodeEulerToRotation" },
  { name: "FunctionNodeInvertRotation" },
  { name: "FunctionNodeRotateRotation" },
  { name: "FunctionNodeRotateVector" },
  { name: "FunctionNodeRotationToAxisAngle" },
  { name: "FunctionNodeRotationToEuler" },
  { name: "FunctionNodeRotationToQuaternion" },
  { name: "FunctionNodeQuaternionToRotation" },
  { name: "FunctionNodeCombineMatrix" },
  { name: "FunctionNodeCombineTransform" },
  { name: "FunctionNodeInvertMatrix" },
  { name: "FunctionNodeMatrixMultiply" },
  { name: "FunctionNodeProjectPoint" },
  { name: "FunctionNodeSeparateMatrix" },
  { name: "FunctionNodeSeparateTransform" },
  { name: "FunctionNodeTransformDirection" },
  { name: "FunctionNodeTransformPoint" },
  { name: "FunctionNodeTransposeMatrix" },
  { name: "FunctionNodeBooleanMath" },
  { name: "ShaderNodeClamp" },
  { name: "FunctionNodeCompare" },
  { name: "ShaderNodeFloatCurve" },
  { name: "FunctionNodeFloatToInt" },
  { name: "ShaderNodeMapRange" },
  { name: "ShaderNodeMath" },
  { name: "ShaderNodeMix" },
  { name: "GeometryNodeUVPackIslands" },
  { name: "GeometryNodeUVUnwrap" },
  { name: "ShaderNodeVectorCurve" },
  { name: "ShaderNodeVectorMath" },
  { name: "ShaderNodeVectorRotate" },
  { name: "ShaderNodeCombineXYZ" },
  { name: "ShaderNodeMix" },
  { name: "ShaderNodeSeparateXYZ" },
  { name: "GeometryNodeGetNamedGrid" },
  { name: "GeometryNodeStoreNamedGrid" },
  { name: "GeometryNodeSampleGrid" },
  { name: "GeometryNodeSampleGridIndex" },
  { name: "GeometryNodeVolumeToMesh" },
  { name: "GeometryNodeGridToMesh" },
  { name: "GeometryNodeSDFGridBoolean" },
  { name: "GeometryNodeVolumeCube" },
];
